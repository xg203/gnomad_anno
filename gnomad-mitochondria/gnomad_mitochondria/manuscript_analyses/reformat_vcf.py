#!/usr/bin/python

import argparse
import csv
import decimal
import gzip
import itertools
import json
import sys
from typing import Dict, Tuple


csv.field_size_limit(sys.maxsize)

"""gather additional annotations for gnomAD mitochondrial variants, not in VCF:
MITOMAP: disease-associated variants, and database allele frequencies
APOGEE: in silico prediction for non-synonymous variants
HmtVar: in silico prediction for tRNA variants"""


def in_mitomap(other_databases_path: str):
    """Extract a disease-associated variant list, and GenBank allele frequencies from MITOMAP database.

    :param other_databases_path: path to the other_databases directory with required files
    :return: mitomap_counts and matches_disease dictionaries with relevant information
    """
    mitomap_counts = {}
    matches_disease = {}

    with open(other_databases_path + "MITOMAP_polymorphisms_02022021.cgi") as csv_file:
        var_list = csv.DictReader(csv_file, delimiter="\t")

        for row in var_list:  # for each variant in mitomap
            # need to use allele counts (named "gbcnt") to convert to allele frequency, as if gbcnt = 1, gbfreq is written as 0.0 (rounded) in MITOMAP, total used for denominator n=51836
            mitomap_counts[str(row["pos"]), str(row["ref"]), str(row["alt"])] = float(
                decimal.Decimal(row["gbcnt"]) / 51836
            )

    with open(other_databases_path + "MITOMAP_disease_02012021.cgi") as csv_file:
        var_list = csv.DictReader(csv_file, delimiter="\t")

        for row in var_list:
            if (
                str(row["pos"]),
                str(row["ref"]),
                str(row["alt"]),
            ) not in mitomap_counts:
                mitomap_counts[
                    str(row["pos"]), str(row["ref"]), str(row["alt"])
                ] = float(decimal.Decimal(row["gbcnt"]) / 51836)
            if (row["status"] == "Cfrm") or (
                row["status"] == "Reported"
            ):  # gather disease-associated variants
                matches_disease[str(row["pos"]), str(row["ref"]), str(row["alt"])] = (
                    row["status"],
                    row["heteroplasmy"],
                    row["homoplasmy"],
                    row["disease"],
                )

    return (mitomap_counts, matches_disease)


def apogee(insilicos_path: str):
    """Extract APOGEE in silico predictions for non-synonymous variants.

    :param insilicos_path: path to the insilicos directory with required file
    :return: matches_apogee dictionary with APOGEE prediction for every variant
    """
    with open(insilicos_path + "MitImpact_db_3.0.6.txt") as mitimpact:
        mitimpact = csv.DictReader(mitimpact, delimiter="\t")

        matches_apogee = {}

        for row in mitimpact:
            matches_apogee[
                (row["Start"], row["Ref"], row["Alt"], row["Gene_symbol"])
            ] = row["APOGEE"]

    return matches_apogee


def hmtvar_annotations(insilicos_path: str):
    """Extract HmtVar in silico predictions for tRNA variants, retrieved via API using get_hmtvar.py.

    :param insilicos_path: path to the insilicos directory with required file
    :return: matches_hmtvar dictionary with HmtVar prediction for every variant
    """
    with open(insilicos_path + "hmtvar_annotations.txt") as hmtvar:
        hmtvar = csv.DictReader(hmtvar, delimiter="\t")

        matches_hmtvar = {}

        for row in hmtvar:
            insilico = ""
            # extract the in silico prediction from the annotation
            if len(row["HmtVar"]) > 3:
                annotation = json.loads(row["HmtVar"])
                insilico = str(annotation["pathogenicity"])

            matches_hmtvar[(row["POS"], row["REF"], row["ALT"])] = insilico

    return matches_hmtvar


"""extract relevant data from gnomAD sample sheet and VCF:
haplogroup of each sample, heteroplasmy of each variant call, haplogroup associated with each variant call, allele frequencies and maximum heteroplasmy, and vep annotations"""


def samples(gnomAD_path: str):
    """Create dictionary of sample ID and haplogroup.

    :param gnomAD_path: path to the gnomAD VCF
    :return: matches_samples dictionary with the haplogroup of every sample
    """
    with open(gnomAD_path + "t21/sample_annotations_gnomad.txt") as csv_file:
        samples = csv.DictReader(csv_file, delimiter="\t")

        matches_samples = {}

        for row in samples:
            matches_samples[row["s"]] = row["hap"]

    return matches_samples


def parse_vcf(matches_samples: Dict[str, str], gnomAD_path: str):
    """VCF with genotype and heteroplasmy level data for each sample, not publicly available.

    :param matches_samples: dictionary generated by samples function
    :param gnomAD_path: path to the gnomAD VCF
    :return: matches_annotations, matches_insilico dictionaries linking relevant VCF annotations and in silicos predictions to each observed variant
    :return: matches_base, matches_codon dictionaries with maximum heteroplasmy observed at each base and codon
    """
    with gzip.open(
        gnomAD_path + "t21/sample_annotations_gnomad.vcf.bgz", mode="rt"
    ) as tsv_file:
        vcf = csv.reader(tsv_file, delimiter="\t")
        # vep annotations are per header
        header = "Allele|Consequence|IMPACT|SYMBOL|Gene|Feature_type|Feature|BIOTYPE|EXON|INTRON|HGVSc|HGVSp|cDNA_position|CDS_position|Protein_position|Amino_acids|Codons|ALLELE_NUM|DISTANCE|STRAND|VARIANT_CLASS|MINIMISED|SYMBOL_SOURCE|HGNC_ID|CANONICAL|TSL|APPRIS|CCDS|ENSP|SWISSPROT|TREMBL|UNIPARC|GENE_PHENO|SIFT|PolyPhen|DOMAINS|HGVS_OFFSET|MOTIF_NAME|MOTIF_POS|HIGH_INF_POS|MOTIF_SCORE_CHANGE|LoF|LoF_filter|LoF_flags|LoF_info"
        matches_annotations = (
            {}
        )  # extracting vep, allele frequencies, maximum heteroplasmy and other annotations from VCF
        matches_base = {}  # this is the maximum heteroplasmy of a SNV at each base
        matches_codon = (
            {}
        )  # this is the maximum heteroplasmy of a non-synonymous SNV at each codon in protein-coding genes
        matches_insilico = {}  # extracting in silico annotations in VCF
        sample_ids = (
            {}
        )  # this is used to annotate the haplogroup of the individuals the variant is called in

        for row_index, row in enumerate(
            itertools.islice(vcf, 68, None)
        ):  # row with header and sample IDs is 69 for t21
            all_het = []  # resets every row/variant
            haplos = []
            # this step extracts the heteroplasmy level of variant calls, and the haplogroup of the samples with the variant call
            if (row[6] == "PASS") or (row_index == 0):  # pass only sites and header
                for col_index, cell in enumerate(
                    itertools.islice(row, 9, None)
                ):  # start from column 10, the first column with sample genotype data
                    if row_index == 0:  # ie if the first row (the header)
                        sample_ids[
                            col_index
                        ] = cell  # building a dictionary of the sample IDs
                    else:
                        genotype = cell.split(":")[0]
                        if (genotype == "0/1") or (genotype == "1/1"):
                            col_header = sample_ids[col_index]  # sample
                            haplogroup = matches_samples[
                                col_header
                            ]  # haplogroup of sample
                            haplos.append(haplogroup)
                            heteroplasmy = cell.split(":")[2]
                            all_het.append(heteroplasmy)

            if row[6] == "PASS":
                POS = row[1]
                REF = row[3]
                ALT = row[4]
                # will convert annotations in row[7] (column 8) to dictionary using = and ; separators
                # first need to handle annotations that don't have = separators
                # also handle the use of = in synonymous HVGSp (within vep field)
                if "hap_defining_variant;" in row[7]:
                    row[7] = row[7].replace(
                        "hap_defining_variant;", "hap_defining_variant=yes;"
                    )
                else:
                    row[7] = row[7] + ";hap_defining_variant=no"
                if "common_low_heteroplasmy;" in row[7]:
                    row[7] = row[7].replace(
                        "common_low_heteroplasmy;", "common_low_heteroplasmy=yes;"
                    )
                else:
                    row[7] = row[7] + ";common_low_heteroplasmy=no"
                if "=|" in row[7]:  # synonymous variants
                    row[7] = row[7].replace("=|", "|")
                info = dict(
                    (k.strip(), v.strip())
                    for k, v in (item.split("=") for item in row[7].split(";"))
                )
                max_hl = info["max_hl"]
                VARIANT_CLASS = info["vep"].split("|")[20]
                SYMBOL = info["vep"].split("|")[3]
                BIOTYPE = info["vep"].split("|")[7]
                Consequence = info["vep"].split("|")[1]
                Protein_position = info["vep"].split("|")[14]  # residue/codon
                HGVSc = info["vep"].split("|")[10]
                HGVSp = info["vep"].split("|")[11]

                max_hap_AF_hom = max_pop_AF_hom = 0.0  # reset each variant
                # maximum AF_hom per haplogroup, and per population
                for value in info["hap_AF_hom"].split("|"):
                    if (value != ".") and (float(value) >= float(max_hap_AF_hom)):
                        max_hap_AF_hom = value
                for value in info["pop_AF_hom"].split("|"):
                    if (value != ".") and (float(value) >= float(max_pop_AF_hom)):
                        max_pop_AF_hom = value

                matches_annotations[POS, REF, ALT, SYMBOL] = (
                    max_hl,
                    info["AN"],
                    info["AC_hom"],
                    info["AC_het"],
                    info["AF_hom"],
                    info["AF_het"],
                    info["faf_hapmax_hom"],
                    VARIANT_CLASS,
                    SYMBOL,
                    BIOTYPE,
                    Consequence,
                    Protein_position,
                    HGVSc,
                    HGVSp,
                    all_het,
                    haplos,
                    max_hap_AF_hom,
                    max_pop_AF_hom,
                )

                # for max heteroplasmy at base, SNVs only
                # for every SNV - if the base position of the variant is not in the matches_base dictionary,
                # or if the max_hl for the variant position in the dictionary is lower than the max_hl value for this variant (at the same position)
                # the variant's max_hl will be set as the maximum heteroplasmy for the base position
                if VARIANT_CLASS == "SNV":
                    if (not POS in matches_base) or (matches_base[POS] < max_hl):
                        matches_base[POS] = max_hl
                # for max heteroplasmy at codon, for SNVs in protein-coding genes only
                # for every non-synonymous SNV - if the codon (Protein_position) of the variant in the gene (SYMBOL) is not in the matches_codon dictionary,
                # or if the max_hl for the codon in the dictionary is lower than the max_hl value for this non-synonymous variant (at the same codon)
                # the variants's max_hl will be set as the maximum heteroplasmy for the codon
                if (
                    (BIOTYPE == "protein_coding")
                    and (VARIANT_CLASS == "SNV")
                    and (Consequence != "synonymous_variant")
                ):
                    if (not (SYMBOL, Protein_position) in matches_codon) or (
                        matches_codon[(SYMBOL, Protein_position)] < max_hl
                    ):
                        matches_codon[(SYMBOL, Protein_position)] = max_hl
                # tRNA in silicos in VCF
                if (BIOTYPE == "Mt_tRNA") and (VARIANT_CLASS == "SNV"):
                    if not (SYMBOL, POS, ALT) in matches_insilico:
                        matches_insilico[(SYMBOL, POS, ALT)] = (
                            info["mitotip_trna_prediction"],
                            info["pon_mt_trna_prediction"],
                        )

                if info["vep"].count("|") > header.count(
                    "|"
                ):  # then is two annotations, variant lies in two genes
                    SYMBOL = info["vep"].split("|")[
                        48
                    ]  # plus 45, header.count('|') = 44
                    BIOTYPE = info["vep"].split("|")[52]
                    Consequence = info["vep"].split("|")[46]
                    Protein_position = info["vep"].split("|")[59]
                    HGVSc = info["vep"].split("|")[55]
                    HGVSp = info["vep"].split("|")[56]

                    # create a second entry for variants in two genes, with two consequences
                    matches_annotations[POS, REF, ALT, SYMBOL] = (
                        max_hl,
                        info["AN"],
                        info["AC_hom"],
                        info["AC_het"],
                        info["AF_hom"],
                        info["AF_het"],
                        info["faf_hapmax_hom"],
                        VARIANT_CLASS,
                        SYMBOL,
                        BIOTYPE,
                        Consequence,
                        Protein_position,
                        HGVSc,
                        HGVSp,
                        all_het,
                        haplos,
                        max_hap_AF_hom,
                        max_pop_AF_hom,
                    )

                    # for max heteroplasmy at codon, for SNVs only
                    # to catch variants where one consequence but not other is protein-changing
                    if (
                        (BIOTYPE == "protein_coding")
                        and (VARIANT_CLASS == "SNV")
                        and (Consequence != "synonymous_variant")
                    ):
                        if (not (SYMBOL, Protein_position) in matches_codon) or (
                            matches_codon[(SYMBOL, Protein_position)] < max_hl
                        ):
                            matches_codon[(SYMBOL, Protein_position)] = max_hl

                    # tRNA in silicos in VCF
                    # to catch variants in two different tRNA genes
                    if (BIOTYPE == "Mt_tRNA") and (VARIANT_CLASS == "SNV"):
                        if not (SYMBOL, POS, ALT) in matches_insilico:
                            matches_insilico[(SYMBOL, POS, ALT)] = (
                                info["mitotip_trna_prediction"],
                                info["pon_mt_trna_prediction"],
                            )

    return (matches_annotations, matches_base, matches_codon, matches_insilico)


"""now generate 'reformated.vcf', which is used to produce fig5, fig6, figS5d, figS7, figS8 and table S3
this includes the above gathered annotations from gnomAD VCF and other sources"""


def write_file_for_figures(
    matches_annotations: Dict[
        Tuple[str, str, str, str],
        Tuple[
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            list,
            list,
            str,
            str,
        ],
    ],
    matches_disease: Dict[Tuple[str, str, str], Tuple[str, str, str, str]],
    matches_base: Dict[str, str],
    matches_codon: Dict[Tuple[str, str], str],
    matches_insilico: Dict[Tuple[str, str, str], Tuple[str, str]],
    matches_apogee: Dict[Tuple[str, str, str, str], str],
    matches_hmtvar: Dict[Tuple[str, str, str], str],
    gnomAD_path: str,
):
    """Generate a VCF of all variants observed in gnomAD, with annotations that can be easily parsed for figure generation.

    :param matches_annotations: dictionary linking gnomAD variants to relevant VCF annotations, produced by parse_vcf function
    :param matches_disease: dictionary containing all reported disease-associated variants in MITOMAP, produced by in_mitomap function
    :params matches_insilico, matches_apogee, matches_hmtvar: dictionaries with in silicos predictions of each variant, produced by parse_vcf, apogee and hmtvar_annotations functions
    :params matches_base, matches_codon: dictionaries with maximum heteroplasmy observed at each base and codon in gnomAD, produced by parse_vcf function
    :param gnomAD_path: path to the gnomAD VCF
    """
    with gzip.open(
        gnomAD_path + "t21/sample_annotations_gnomad.vcf.bgz", mode="rt"
    ) as tsv_file:
        vcf = csv.reader(tsv_file, delimiter="\t")

        file = open("reformated.vcf", "w")
        header = "POS	REF	ALT	max_hl	AN	AC_hom	AC_het	AF_hom	AF_het	faf_hapmax_hom	VARIANT_CLASS	SYMBOL	BIOTYPE	Consequence	Protein_position	HGVSc	HGVSp	all_hl	all_haplogroups	max_hap_AF_hom	max_pop_AF_hom	max_hl_SNV_base	max_hl_nonsyn_SNV_codon	Mitomap_dz_status	Mitomap_dz_heteroplasmy	Mitomap_dz_homoplasmy	Mitomap_disease	APOGEE	Mitotip	Pon_mt_trna	Hmtvar"
        file.write(header + "\n")

        for row in vcf:
            if not row[0].startswith("#"):
                if row[6] == "PASS":  # pass only sites
                    POS = row[1]
                    REF = row[3]
                    ALT = row[4]
                    vep = row[7].split("vep=")[1].split(";")[0]
                    SYMBOL = vep.split("|")[3]
                    Protein_position = vep.split("|")[14]

                    if (
                        POS in matches_base
                    ):  # this is the maximum heteroplasmy of a SNV at each base
                        max_base = matches_base[POS]
                    else:
                        max_base = 0

                    if (
                        SYMBOL,
                        Protein_position,
                    ) in matches_codon:  # this is the maximum heteroplasmy of a non-synonymous SNV at each codon in protein-coding genes
                        max_codon = matches_codon[(SYMBOL, Protein_position)]
                    else:
                        max_codon = 0

                    if (
                        POS,
                        REF,
                        ALT,
                    ) in matches_disease:  # this is MITOMAP disease-associated variant
                        mitomap_status = matches_disease[(POS, REF, ALT)][0]
                        mitomap_het = matches_disease[(POS, REF, ALT)][1]
                        mitomap_hom = matches_disease[(POS, REF, ALT)][2]
                        mitomap_dz = matches_disease[(POS, REF, ALT)][3]
                    else:
                        mitomap_status = mitomap_het = mitomap_hom = mitomap_dz = ""

                    if (
                        SYMBOL,
                        POS,
                        ALT,
                    ) in matches_insilico:  # this is tRNA in silicos from the gnomAD VCF
                        mitotip = matches_insilico[(SYMBOL, POS, ALT)][0]
                        pon_mt = matches_insilico[(SYMBOL, POS, ALT)][1]
                    else:
                        mitotip = pon_mt = ""

                    if (
                        POS,
                        REF,
                        ALT,
                        SYMBOL,
                    ) in matches_apogee:  # this is additional in silico for non-synonymous variants
                        apogee = matches_apogee[(POS, REF, ALT, SYMBOL)]
                    else:
                        apogee = ""

                    if ((POS, REF, ALT) in matches_hmtvar) and (
                        SYMBOL.startswith("MT-T")
                    ):  # this is additional in silico for tRNA variants
                        hmtvar = matches_hmtvar[(POS, REF, ALT)]
                    else:
                        hmtvar = ""

                    file.write(
                        str(POS)
                        + "\t"
                        + str(REF)
                        + "\t"
                        + str(ALT)
                        + "\t"
                        + "\t".join(
                            str(x) for x in matches_annotations[POS, REF, ALT, SYMBOL]
                        )
                        + "\t"
                        + str(max_base)
                        + "\t"
                        + str(max_codon)
                        + "\t"
                        + str(mitomap_status)
                        + "\t"
                        + str(mitomap_het)
                        + "\t"
                        + str(mitomap_hom)
                        + "\t"
                        + str(mitomap_dz)
                        + "\t"
                        + str(apogee)
                        + "\t"
                        + str(mitotip)
                        + "\t"
                        + str(pon_mt)
                        + "\t"
                        + str(hmtvar)
                        + "\n"
                    )

                    if (
                        vep.count("|") > 44
                    ):  # if two annotations, variant lies in two genes
                        SYMBOL = vep.split("|")[48]
                        Protein_position = vep.split("|")[59]

                        if (
                            SYMBOL,
                            Protein_position,
                        ) in matches_codon:  # this is the maximum heteroplasmy of a non-synonymous SNV at each codon in protein-coding genes
                            max_codon = matches_codon[(SYMBOL, Protein_position)]
                        else:
                            max_codon = 0

                        if (
                            SYMBOL,
                            POS,
                            ALT,
                        ) in matches_insilico:  # this is tRNA in silicos from the gnomAD VCF
                            mitotip = matches_insilico[(SYMBOL, POS, ALT)][0]
                            pon_mt = matches_insilico[(SYMBOL, POS, ALT)][1]
                        else:
                            mitotip = pon_mt = ""

                        if (
                            POS,
                            REF,
                            ALT,
                            SYMBOL,
                        ) in matches_apogee:  # this is additional in silico for non-synonymous variants
                            apogee = matches_apogee[(POS, REF, ALT, SYMBOL)]
                        else:
                            apogee = ""

                        if ((POS, REF, ALT) in matches_hmtvar) and (
                            SYMBOL.startswith("MT-T")
                        ):  # this is additional in silico for tRNA variants
                            hmtvar = matches_hmtvar[(POS, REF, ALT)]
                        else:
                            hmtvar = ""

                        file.write(
                            str(POS)
                            + "\t"
                            + str(REF)
                            + "\t"
                            + str(ALT)
                            + "\t"
                            + "\t".join(
                                str(x)
                                for x in matches_annotations[POS, REF, ALT, SYMBOL]
                            )
                            + "\t"
                            + str(max_base)
                            + "\t"
                            + str(max_codon)
                            + "\t"
                            + str(mitomap_status)
                            + "\t"
                            + str(mitomap_het)
                            + "\t"
                            + str(mitomap_hom)
                            + "\t"
                            + str(mitomap_dz)
                            + "\t"
                            + str(apogee)
                            + "\t"
                            + str(mitotip)
                            + "\t"
                            + str(pon_mt)
                            + "\t"
                            + str(hmtvar)
                            + "\n"
                        )


"""now generate a second output file 'annotated_synthetic.vcf', which is used to produce table S4
first use a VEP annotated synthetic VCF for all possible SNVs in the mtDNA to create dictionaries of the consequences and locus of each possible SNV
gather allele frequency and maximum heteroplasmy data from HelixMTdb for annotating, also annoate with MITOMAP allele frequency and disease-assocated variants gathered above"""


def consequences(synthetic_vcf_path: str):
    """Create dictionaries of the VEP consequences and locus of every possible single nucleotide variant in the mtDNA.

    :param synthetic_vcf_path: path to the VEP annotated synthetic VCF output of split_vars_two_genes.py
    :return: matches_locus, matches_conseq, matches_HGVSc, matches_HGVSp dictionaries linking relavant annotations to every base or variant
    """
    with open(
        synthetic_vcf_path + "NC_012920.1_synthetic_vep_splitvarstwogenes.vcf"
    ) as vcf:  # this file has been edited so that for variants in two genes, the consequence on each gene is listed on a separate line using split_vars_two_genes.py
        vcf = csv.DictReader(vcf, delimiter="\t")

        matches_locus = {}  # gene name
        matches_conseq = {}  # ie synonymous, missense, etc
        matches_HGVSp = {}  # HGVSp
        matches_HGVSc = {}  # HGVSc

        for row in vcf:
            base = str(row["POS"])
            alt = row["ALT"]
            gene = row["SYMBOL"]

            if not base in matches_locus:
                matches_locus[base] = []
                if gene:  # ie if base lies in a gene
                    matches_locus[base] = [gene]
                else:
                    matches_locus[base] = ["non-coding"]
            else:  # if base lies in two genes
                if not gene:
                    gene = "non-coding"
                if (
                    not gene in matches_locus[base]
                ):  # so only adding different gene names
                    matches_locus[base].append(gene)

            if (
                not (base, alt) in matches_conseq
            ):  # every base position will have a consequence
                matches_conseq[(base, alt)] = [row["Consequence"]]
            else:
                matches_conseq[(base, alt)].append(row["Consequence"])

            if not (base, alt) in matches_HGVSp:
                matches_HGVSp[(base, alt)] = [row["HGVSp"]]
            else:
                matches_HGVSp[(base, alt)].append(row["HGVSp"])

            if not (base, alt) in matches_HGVSc:
                matches_HGVSc[(base, alt)] = [row["HGVSc"]]
            else:
                matches_HGVSc[(base, alt)].append(row["HGVSc"])

    return (matches_locus, matches_conseq, matches_HGVSc, matches_HGVSp)


def in_helix(other_databases_path: str):
    """Extract allele frequency and maximum heteroplasmy data from the HelixMTdb database.

    :param other_databases_path: path to the other_databases directory with required file
    :return: helix_counts dictionary with relevant annotations for all observed variants
    """
    with open(other_databases_path + "HelixMTdb_20200327.tsv") as csv_file:
        var_list = csv.DictReader(csv_file, delimiter="\t")

        helix_counts = {}

        for row in var_list:
            pos = str(row["locus"].split("chrM:")[1])
            ref = str(row["alleles"].split('"')[1])
            alt = str(row["alleles"].split('"')[3])

            if float(row["AF_hom"]) > 0:
                max_het = float(1)
            elif float(row["AF_hom"]) == 0:
                max_het = float(row["max_ARF"])

            helix_counts[pos, ref, alt] = (
                max_het,
                float(row["AF_hom"]),
                float(row["AF_het"]),
            )

    return helix_counts


def annotate_syn_vcf(
    matches_annotations: Dict[
        Tuple[str, str, str, str],
        Tuple[
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            str,
            list,
            list,
            str,
            str,
        ],
    ],
    helix_counts: Dict[Tuple[str, str, str], Tuple[float, float, float]],
    mitomap_counts: Dict[Tuple[str, str, str], float],
    matches_locus: Dict[str, str],
    matches_conseq: Dict[Tuple[str, str], str],
    matches_HGVSc: Dict[Tuple[str, str], str],
    matches_HGVSp: Dict[Tuple[str, str], str],
    synthetic_vcf_path: str,
):
    """Generate a VCF of all possible SNVs in the mtDNA, with annotations that can be easily parsed for table generation.

    :param matches_annotations: dictionary linking gnomAD variants to relevant VCF annotations, produced by parse_vcf function
    :param helix_counts: dictionary with relevant annotations for all observed variants in HelixMTdb, produced by in_helix function
    :param mitomap_counts: dictionary with relevant annotations for all observed variants in MITOMAP, produced by in_mitomap function
    :params matches_locus, matches_conseq, matches_HGVSc, matches_HGVSp: dictionaries linking relavant annotations to every base or variant, produced by consequences function
    :param synthetic_vcf_path: path to the VEP annotated synthetic VCF
    """
    with open(synthetic_vcf_path + "NC_012920.1_synthetic_vep.vcf") as csv_file:
        synt_vcf = csv.reader(csv_file, delimiter="\t")

        file = open("annotated_synthetic.vcf", "w")
        header = "POS	REF	ALT	SYMBOL	Consequence	HGVSc	HGVSp	gnomAD_max_hl	gnomAD_AF_hom	gnomAD_AF_het	Helix_max_hl	Helix_af_hom	Helix_af_het	Mitomap_af	Mitomap_dz_status	Mitomap_dz_heteroplasmy	Mitomap_dz_homoplasmy"
        file.write(header + "\n")

        for row in synt_vcf:
            if not row[0].startswith("#"):
                POS = row[1]
                REF = row[3]
                ALT = row[4]
                SYMBOL = row[7].split("|")[3]
                if (
                    POS,
                    REF,
                    ALT,
                    SYMBOL,
                ) in matches_annotations:  # annotations from gnomAD VCF
                    in_gnomad_max = matches_annotations[(POS, REF, ALT, SYMBOL)][0]
                    in_gnomad_afhom = matches_annotations[(POS, REF, ALT, SYMBOL)][4]
                    in_gnomad_afhet = matches_annotations[(POS, REF, ALT, SYMBOL)][5]
                else:
                    in_gnomad_max = in_gnomad_afhom = in_gnomad_afhet = 0

                if (POS, REF, ALT) in helix_counts:  # annotations from HelixMTdb
                    in_helix_max = helix_counts[(POS, REF, ALT)][0]
                    in_helix_afhom = helix_counts[(POS, REF, ALT)][1]
                    in_helix_afhet = helix_counts[(POS, REF, ALT)][2]
                else:
                    in_helix_max = in_helix_afhom = in_helix_afhet = 0

                if (POS, REF, ALT) in mitomap_counts:  # annotations from MITOMAP
                    in_mitomap = mitomap_counts[(POS, REF, ALT)]
                else:
                    in_mitomap = 0

                if (
                    POS,
                    REF,
                    ALT,
                ) in matches_disease:  # disease-associated variants from MITOMAP
                    mitomap_status = matches_disease[(POS, REF, ALT)][0]
                    mitomap_het = matches_disease[(POS, REF, ALT)][1]
                    mitomap_hom = matches_disease[(POS, REF, ALT)][2]
                else:
                    mitomap_status = mitomap_het = mitomap_hom = ""

                file.write(
                    str(POS)
                    + "\t"
                    + str(REF)
                    + "\t"
                    + str(ALT)
                    + "\t"
                    + str(matches_locus[POS]).strip("[]").replace("'", "")
                    + "\t"
                    + str(matches_conseq[(POS, ALT)]).strip("[]").replace("'", "")
                    + "\t"
                    + str(matches_HGVSc[(POS, ALT)]).strip("[]").replace("'", "")
                    + "\t"
                    + str(matches_HGVSp[(POS, ALT)]).strip("[]").replace("'", "")
                    + "\t"
                    + str(in_gnomad_max)
                    + "\t"
                    + str(in_gnomad_afhom)
                    + "\t"
                    + str(in_gnomad_afhet)
                    + "\t"
                    + str(in_helix_max)
                    + "\t"
                    + str(in_helix_afhom)
                    + "\t"
                    + str(in_helix_afhet)
                    + "\t"
                    + str(in_mitomap)
                    + "\t"
                    + str(mitomap_status)
                    + "\t"
                    + str(mitomap_het)
                    + "\t"
                    + str(mitomap_hom)
                    + "\n"
                )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--other_databases_path",
        help="path to directory with MITOMAP and HelixMTdb files",
        required=False,
        default="final_data_files/other_databases/",
    )
    parser.add_argument(
        "--insilicos_path",
        help="path to directory with APOGEE and HmtVar files",
        required=False,
        default="final_data_files/insilicos/",
    )
    parser.add_argument(
        "--synthetic_vcf_path",
        help="path to directory with synthetic vcf files",
        required=False,
        default="final_data_files/synthetic_vcf/",
    )
    parser.add_argument(
        "--gnomAD_path",
        help="path to directory with gnomAD files (not publicly available)",
        required=False,
        default="final_data_files/gnomAD/",
    )
    args = parser.parse_args()

    print(
        "Starting!\nThis script will produce 2 output files: reformated.vcf and annotated_synthetic.vcf, which are the input files for the R scripts used to produce the figures and tables"
    )

    # gather annotations for output "reformated.vcf", these are additional insilico and population frequency annotations
    (mitomap_counts, matches_disease) = in_mitomap(args.other_databases_path)
    matches_apogee = apogee(args.insilicos_path)
    matches_hmtvar = hmtvar_annotations(args.insilicos_path)
    print(
        "gathered annotations!\nNow will parse the gnomAD data, this might take ~15 minutes"
    )
    # these are annotations extracted from the gnomAD data
    matches_samples = samples(args.gnomAD_path)
    (matches_annotations, matches_base, matches_codon, matches_insilico) = parse_vcf(
        matches_samples, args.gnomAD_path
    )
    # now write the output file "reformated.vcf", which is used to produce fig5, fig6, figS5d, figS7, figS8 and table S3
    write_file_for_figures(
        matches_annotations,
        matches_disease,
        matches_base,
        matches_codon,
        matches_insilico,
        matches_apogee,
        matches_hmtvar,
        args.gnomAD_path,
    )
    print(
        "written file reformated.vcf!\nNow will make the second output file annotated_synthetic.vcf"
    )

    # now generate a second output file "annotated_synthetic.vcf", which is used to produce table S4, this output needs additional annotations vs "reformated.vcf", including from HelixMTdb
    (matches_locus, matches_conseq, matches_HGVSc, matches_HGVSp) = consequences(
        args.synthetic_vcf_path
    )
    helix_counts = in_helix(args.other_databases_path)
    annotate_syn_vcf(
        matches_annotations,
        helix_counts,
        mitomap_counts,
        matches_locus,
        matches_conseq,
        matches_HGVSc,
        matches_HGVSp,
        args.synthetic_vcf_path,
    )
    print("written file annotated_synthetic.vcf!\nScript is now complete")
